<!DOCTYPE html>
<html lang="ko">
  <!-- v1.2578 (ë‹¨ë‹µí˜• ì±„ì  ê¸°ëŠ¥ ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2577 (í–‰ë ¬í˜•: ì‹œê°ì  ì…ë ¥ì¹¸ ìë™ ìƒì„± â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€)-->
  <!-- v1.2576 (ë¬¸ì¥ ë‹¤ì¤‘ì •ë‹µí˜• ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2575 (í•œê¸€ ììŒí˜• ì±„ì  ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2573 (ìˆ˜ì‹í˜• êµí™˜ë²•ì¹™ ì™„ì „ëŒ€ì‘) -->
  <!-- v1.2572 (ìˆ˜ì‹í˜• êµí™˜ë²•ì¹™ í—ˆìš© ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2571 (ì¸ìˆ˜ë¶„í•´í˜• êµí™˜ê·œì¹™ ì•ˆì •í™”) -->
  <!-- v1.2570 (ì¸ìˆ˜ë¶„í•´í˜• ì±„ì  ê¸°ëŠ¥ ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2569 (ë¬¸ììˆ˜ì‹í˜• ì±„ì  ê¸°ëŠ¥ ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì±„ì  í˜ì´ì§€</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    .question-line{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .question-card{background:#f8f9ff;border:1px solid #dde2f2;border-radius:10px;padding:8px 12px;margin-bottom:8px}
    .question-card h3{margin:0;font-size:14px;color:#2a5adf;font-weight:600;width:55px;text-align:right}
    .dual-inputs,.multi-inputs,.var-inputs{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .dual-inputs label,.multi-inputs label,.var-inputs label{font-size:13px;font-weight:600;color:#333}
    .dual-inputs input,.multi-inputs input,.var-inputs input{width:90px;padding:4px;font-size:13px;border:1px solid #ccc;border-radius:5px}
    .multi-inputs input.small-input,.var-inputs input.small-input{width:45px;font-size:12px}
    .answer-input.disabled{background:#eee;color:#666;border:1px solid #ccc;cursor:not-allowed}
    .check-btn{background:#2a5adf;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
    .check-btn.correct{background:#e4f9ec;color:#0b7a32;border:1.5px solid #1a8f4c}
    .check-btn.wrong{background:#ffe9e9;color:#c81c1c;border:1.5px solid #d93025}
    .result-inline{font-weight:bold;white-space:nowrap;min-width:90px;text-align:right;margin-left:8px;font-size:13px}
    .bottom-buttons{text-align:center;margin-top:20px}
    #check-all{background:#444;color:#fff;border:none;padding:8px 14px;border-radius:8px;font-size:13px;cursor:pointer}
    #check-all:hover{background:#222}
    .matrix-input {
      display: inline-block;
      border: 1px solid #ccc;
      padding: 6px;
      border-radius: 8px;
      background: #fafafa;
    }
    .matrix-row {
      display: flex;
      gap: 6px;
      margin-bottom: 4px;
      justify-content: center;
    }
    .matrix-cell {
      width: 45px;
      text-align: center;
      padding: 3px;
      font-size: 13px;
    }

  </style>
</head>

<body>
  <div class="container">
    <h1 id="page-title">ğŸ“˜ ì±„ì  í˜ì´ì§€</h1>
    <div id="question-container">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>
    <div class="bottom-buttons">
      <button id="check-all">ğŸ§® ëª¨ë‘ ì±„ì </button><br />
      <button onclick="window.location.href='index.html'" class="back-btn">â¬… ìª½ ì„ íƒìœ¼ë¡œ ëŒì•„ê°€ê¸°</button>
    </div>
  </div>

<script>
const API_URL="https://script.google.com/macros/s/AKfycbwvdVkZm4EVUVeHaelSzQPrtFmOA2bB3A7HFMHEIbb42SbDFfNusYrsLyFbNakLmlMzcQ/exec";

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê³µí†µ ì •ê·œí™” â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function normalize(s){
  return (s||"")
    .replace(/root/gi,"âˆš").replace(/ë£¨íŠ¸/g,"âˆš")
    .replace(/âˆ’/g,"-").replace(/Ã—/g,"*").replace(/\*/g,"")
    .replace(/\s*ë˜ëŠ”\s*(?=[a-zA-Zê°€-í£]+\s*=)/g, ",")
    .replace(/ï¼Œ/g, ",")
    .replace(/\s*,\s*/g, ",")
    .replace(/\s+/g,"")
    .replace(/,$/,"").replace(/^,/,"")
    .trim();
}
/* ì •ë‹µ ë¬¸ìì—´ì„ íŒŒì‹±í•´ í–‰ë ¬ êµ¬ì¡°ë¡œ ë³€í™˜í•˜ê¸° */
function parseMatrixToGrid(str){
  const clean = String(str)
    .replace(/\\begin\{pmatrix\}|\(\\begin\{pmatrix\}\)|\\end\{pmatrix\}|\(|\)|\[|\]/g, "")
    .replace(/,/g, " ")
    .replace(/&/g, " ")
    .replace(/\\\\|\\/g, ";") // í–‰ êµ¬ë¶„
    .replace(/\s+/g, " ")
    .trim();

  const rows = clean.split(";").map(r => r.trim().split(/\s+/).filter(Boolean));
  return rows.filter(r => r.length > 0);
}
/* ì…ë ¥ ìˆœì„œ ìƒê´€ ì—†ìŒ */
function gradeOrderAgnosticList(correct, userList){
  const n=s=>(s||"").replace(/\s+/g,"").trim();
  const C=n(correct).split(",").filter(Boolean);
  const U=userList.map(n);
  if(C.length!==U.length) return false;
  const A=[...C].sort(), B=[...U].sort();
  for(let i=0;i<A.length;i++){if(A[i]!==B[i]) return false;} return true;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê¸°ë³¸ë¬¸ì¥í˜• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeBasicSentence(correct, user){
  const norm = s => (s||"").replace(/\s+/g,"").trim();
  return norm(correct) === norm(user);
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeMultiSentence(correct, user){
  const norm = s => (s||"")
    .replace(/\s+/g,"") // ëª¨ë“  ê³µë°± ì œê±°
    .trim();

  const corrList = norm(correct).split("ë˜ëŠ”").filter(Boolean);
  const userInput = norm(user);

  // ì‚¬ìš©ìê°€ ì—¬ëŸ¬ ë¬¸ì¥ì„ ì…ë ¥í–ˆì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ "ë˜ëŠ”"ìœ¼ë¡œ ë‹¤ì‹œ ë¶„ë¦¬
  const userList = userInput.split("ë˜ëŠ”").filter(Boolean);

  // ì •ë‹µ ëª©ë¡ì´ í•˜ë‚˜ë¼ë„ í¬í•¨ë˜ë©´ ì •ë‹µ
  // (ex: corrList=["A","B","C"], userList=["B","C"] â†’ pass)
  const allCorr = new Set(corrList);
  return userList.every(u => allCorr.has(u));
}

/* í•œê¸€ ììŒí˜• ì±„ì  */
function gradeConsonantAnswer(correct, user){
  const norm = s => (s||"").replace(/\s+/g,"").replace(/,/g,"").trim();
  return norm(correct) === norm(user);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì¸ìˆ˜ë¶„í•´í˜• ì±„ì  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeFactorization(correct, user){
  const splitFactors = s => normalize(String(s)).match(/(?:\([^()]+\)|[^()]+)/g) || [];
  const cParts = splitFactors(correct);
  const uParts = splitFactors(user);
  if(!cParts.length || !uParts.length) return false;

  const isParen = str => str.startsWith("(") && str.endsWith(")");
  const cFront = isParen(cParts[0]) ? "" : cParts[0];
  const uFront = isParen(uParts[0]) ? "" : uParts[0];
  if(cFront !== uFront) return false;

  const cMain = cFront ? cParts.slice(1) : cParts;
  const uMain = uFront ? uParts.slice(1) : uParts;
  if(cMain.length !== uMain.length) return false;

  const sortedC = [...cMain].sort();
  const sortedU = [...uMain].sort();
  for(let i=0;i<sortedC.length;i++){
    if(sortedC[i]!==sortedU[i]) return false;
  }
  return true;
}


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeCommutativeExpression(correct, user){
  // ì „ì²´ ë¬¸ìì—´ ì •ê·œí™”
  const norm = s => (s||"")
    .replace(/âˆ’/g,"-")
    .replace(/\s+/g,"")
    .replace(/\+\-/g,"-")
    .replace(/\-\+/g,"-")
    .replace(/\+\+/g,"+")
    .replace(/\-\-/g,"+")
    .trim();

  // ë¶€í˜¸ í¬í•¨ í•­ ë‹¨ìœ„ ë¶„ë¦¬
  function splitTerms(expr){
    const t = norm(expr);
    // ë§¨ ì•ì— ë¶€í˜¸ê°€ ì—†ìœ¼ë©´ +ë¥¼ ì¶”ê°€
    const prep = /^[+-]/.test(t) ? t : "+" + t;
    // + ë˜ëŠ” - ì•ì—ì„œ ë¶„ë¦¬ (ë¶€í˜¸ ìœ ì§€)
    return prep.split(/(?=[+-])/).map(x => x.trim()).filter(Boolean);
  }

  const corrTerms = splitTerms(correct);
  const userTerms = splitTerms(user);
  if(corrTerms.length !== userTerms.length) return false;

  // í•­ ì •ë ¬ í›„ ë¹„êµ (ìˆœì„œ ë¬´ì‹œ)
  const sortedC = [...corrTerms].sort();
  const sortedU = [...userTerms].sort();

  return JSON.stringify(sortedC) === JSON.stringify(sortedU);
}


/* ê¸°ì¡´ ìœ í‹¸ í•¨ìˆ˜ */
function parseKeyValuePairs(text){
  const pairs=[...String(text).matchAll(/([a-zA-Zê°€-í£]+)\s*=\s*([^,]+)/g)];
  return pairs.map(([,key,val])=>[key.trim(),normalize(val)]);
}
function gradeSpecialPair(correct,user1,user2,key1,key2){
  const norm=normalize;
  const parts=Object.fromEntries(
    correct.replace(/\s+/g,"").split(",").map(p=>p.split(":").map(x=>norm(x)))
  );
  return parts[key1]&&parts[key2]&&norm(parts[key1])===norm(user1)&&norm(parts[key2])===norm(user2);
}
function gradeSystemEquationAsMultiset(correct, inputs){
  const norm=normalize;
  const corrValues=[...correct.matchAll(/=\s*([^,}]+)/g)].map(m=>norm(m[1]));
  const userValues=inputs.map(v=>norm(v));
  if(userValues.length!==corrValues.length) return false;
  return [...userValues].sort().join(",") === [...corrValues].sort().join(",");
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë©”ì¸ ë¡œì§ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
document.addEventListener("DOMContentLoaded",async()=>{
  const page=new URLSearchParams(window.location.search).get("page");
  const title=document.getElementById("page-title");
  const container=document.getElementById("question-container");
  if(!page){container.innerHTML="<p>âŒ ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤.</p>";return;}
  title.textContent=`ğŸ“˜ ${page}ìª½ ì±„ì `;

  try{
    const res=await fetch(API_URL);
    const data=await res.json();
    const filtered=Object.entries(data).filter(([_,q])=>q.page==page).map(([id,q])=>({id,...q}));
    if(filtered.length===0){container.innerHTML="<p>âŒ í•´ë‹¹ ìª½ì˜ ë¬¸í•­ì´ ì—†ìŠµë‹ˆë‹¤.</p>";return;}

    container.innerHTML=filtered.map(q=>{
      const type=(q.type||"").trim();
      const ans =(q.ans ||"").trim();
      let inputHTML="";

      if(["í•œê¸€ ììŒ","ë‹¨ë‹µí˜•","ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©)","ë¬¸ììˆ˜ì‹","ë“±ì‹í˜•","ê¸°ë³¸ë¬¸ì¥","ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€)"].includes(type)){
        inputHTML=`<input type="text" class="answer-input" placeholder="ë‹µì„ ì…ë ¥í•˜ì„¸ìš”" />`;
      }
      /* í–‰ë ¬ */
      else if(type==="í–‰ë ¬"){
        const matrix = parseMatrixToGrid(ans);
        const rows = matrix.length;
        const cols = matrix[0]?.length || 0;

        inputHTML = `
          <div class="matrix-input" data-rows="${rows}" data-cols="${cols}">
            ${matrix.map((row, i) => `
              <div class="matrix-row">
                ${row.map((_, j) =>
                  `<input type="text" class="matrix-cell" data-row="${i}" data-col="${j}" placeholder="${i+1}-${j+1}" />`
                ).join("")}
              </div>
            `).join("")}
          </div>`;
      }
      else if(type==="ì…ë ¥ ìˆœì„œ ìƒê´€ ì—†ìŒ"){
        const n=(ans.match(/,/g)||[]).length+1; const small=n>=5?"small-input":"";
        inputHTML='<div class="multi-inputs">'+Array.from({length:n},(_,i)=>`<input type="text" class="order-agnostic ${small}" data-index="${i}" placeholder="${i+1}" />`).join("")+'</div>';
      }
      /* â‘¡ ê¸°ë³¸ ë³€ìˆ˜ ëŒ€ì…í˜• */
      else if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•"){
        const labels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        const isMany=labels.length>=5?"small-input":"";
        inputHTML=`<div class="var-inputs">${
          labels.map(l=>`<label>${l}</label><input type="text" class="var-basic ${isMany}" data-key="${l}" />`).join("")
        }</div>`;
      }
      /* â‘¢ ë³€ìˆ˜ ëŒ€ì…í˜•(ì—°ë¦½ë°©ì •ì‹) */
      else if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ì—°ë¦½ë°©ì •ì‹)"){
        const labels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        const isMany=labels.length>=5?"small-input":"";
        inputHTML=`<div class="var-inputs">${
          labels.map(l=>`<label>${l}</label><input type="text" class="var-system ${isMany}" data-key="${l}" />`).join("")
        }</div>`;
      }
      /* â‘£ ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹)(nê°œ) */
      else if(/^ë³€ìˆ˜\s*ëŒ€ì…í˜•\(ë°©ì •ì‹\)\(\d+ê°œ\)$/.test(type)){
        const n=parseInt(type.match(/\((\d+)ê°œ\)/)[1]);
        const baseLabels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        const total=baseLabels.length + n;
        const isMany=total>=5?"small-input":"";
        inputHTML=`<div class="var-inputs">` +
          baseLabels.map(v=>`<label>${v}</label><input type="text" class="var-eq ${isMany}" data-key="${v}" />`).join("") +
          Array.from({length:n}).map(()=>`<input type="text" class="extra-eq ${isMany}" />`).join("") +
          `</div>`;
      }
      /* â‘¤ ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹) */
      else if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹)"){
        const labels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        const isMany=labels.length>=5?"small-input":"";
        inputHTML=`<div class="var-inputs">${
          labels.map(l=>`<label>${l}</label><input type="text" class="var-eq ${isMany}" data-key="${l}" />`).join("")
        }</div>`;
      }
      /* â‘¦ ì†Œë¬¸í•­í˜• */
      else if(/\(\d+\)|\([ê°€-ì‚¬]\)/.test(ans)){
        const tokens=ans.match(/\((\d+|[ê°€-ì‚¬])\)/g)||[];
        const isMany=tokens.length>=5?"small-input":"";
        inputHTML=`<div class="multi-inputs">${
          tokens.map((t,i)=>`<label>${t}</label><input type="text" class="subans ${isMany}" data-index="${i}" />`).join("")
        }</div>`;
      }
      /* â‘§ ê°ê´€ì‹ / ë³µìˆ˜í˜• */
      else if(type==="ê°ê´€ì‹"){
        const opts=["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"];
        inputHTML=`<div class="choices">${
          opts.map(o=>`<label><input type="radio" name="${q.id}" value="${o}">${o}</label>`).join("")
        }</div>`;
      }
      else if(type==="ê°ê´€ì‹(ë³µìˆ˜í˜•)"){
        const opts=["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"];
        inputHTML=`<div class="choices">${
          opts.map(o=>`<label><input type="checkbox" name="${q.id}" value="${o}">${o}</label>`).join("")
        }</div>`;
      }
      /* â‘¨ ë‹¨ë‹µí˜• / íŠ¹ìˆ˜í˜• */
      else if(/ëª«\s*:|ë‚˜ë¨¸ì§€\s*:/.test(ans)){
        inputHTML=`<div class="dual-inputs"><label>ëª«</label><input type="text" class="ans1" />
          <label>ë‚˜ë¨¸ì§€</label><input type="text" class="ans2" /></div>`;
      }else if(/ì‹¤ìˆ˜ë¶€ë¶„\s*:|í—ˆìˆ˜ë¶€ë¶„\s*:/.test(ans)){
        inputHTML=`<div class="dual-inputs"><label>ì‹¤ìˆ˜ë¶€ë¶„</label><input type="text" class="ans1" />
          <label>í—ˆìˆ˜ë¶€ë¶„</label><input type="text" class="ans2" /></div>`;
      }else if(/ìµœëŒ“ê°’\s*:|ìµœì†Ÿê°’\s*:/.test(ans)){
        inputHTML=`<div class="dual-inputs"><label>ìµœëŒ“ê°’</label><input type="text" class="ans1" />
          <label>ìµœì†Ÿê°’</label><input type="text" class="ans2" /></div>`;
      }else{
        inputHTML=`<input type="text" class="answer-input disabled" value="ì±„ì  ë¶ˆê°€ëŠ¥ ìœ í˜•" disabled />`;
      }

      return `
        <div class="question-card" data-id="${q.id}">
          <div class="question-line">
            <h3>${q.id.replace("q","")}</h3>
            ${inputHTML}
            <button class="check-btn">ì±„ì </button>
            <span class="result-inline"></span>
          </div>
          <input type="hidden" class="correct-answer" value="${ans}" />
          <input type="hidden" class="answer-type" value="${type}" />
        </div>`;
    }).join("");

    /* ===== ì±„ì  ë¡œì§ ===== */
    function gradeQuestion(card){
      const btn=card.querySelector(".check-btn");
      const result=card.querySelector(".result-inline");
      const correct=card.querySelector(".correct-answer").value.trim();
      const type=card.querySelector(".answer-type").value.trim();
      const norm=normalize;
      // --- ë‹¨ë‹µí˜• ì±„ì 
      if(type==="ë‹¨ë‹µí˜•"){
        const user=normalize(card.querySelector(".answer-input")?.value.trim()||"");
        const corr=normalize(correct);
        return (user===corr)?pass():fail();
      }
      // --- í–‰ë ¬ ì±„ì 
      if(type==="í–‰ë ¬"){
          const corr = parseMatrixToGrid(correct);
          const user = [];
          const rows = corr.length;
          const cols = corr[0].length;

          for(let i=0;i<rows;i++){
            const rowVals=[];
            for(let j=0;j<cols;j++){
              const val=normalize(card.querySelector(`.matrix-cell[data-row="${i}"][data-col="${j}"]`)?.value||"");
              rowVals.push(val);
            }
            user.push(rowVals);
          }

          const sameSize = user.length===corr.length && user.every((r,i)=>r.length===corr[i].length);
          if(!sameSize) return fail();

          const ok = user.every((r,i)=>r.every((v,j)=>normalize(v)===normalize(corr[i][j])));
          return ok ? pass() : fail();
      }

      // --- ê¸°ë³¸ë¬¸ì¥ ì±„ì 
      if(type==="ê¸°ë³¸ë¬¸ì¥"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeBasicSentence(correct,user)?pass():fail();
      }
            // --- ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€) ì±„ì 
      if(type==="ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€)"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeMultiSentence(correct,user)?pass():fail();
      }

      // --- í•œê¸€ ììŒí˜• ì±„ì 
      if(type==="í•œê¸€ ììŒ") {
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeConsonantAnswer(correct,user)?pass():fail();
      }
      // --- ì¸ìˆ˜ë¶„í•´í˜• ì±„ì  ---
      if(type==="ì¸ìˆ˜ë¶„í•´"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeFactorization(correct,user)?pass():fail();
      }

      /* âœ… ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©) */
      if(type==="ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©)"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeCommutativeExpression(correct,user)?pass():fail();
      }

      // --- ê¸°ì¡´ ìœ í˜•ë“¤ ---
      if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•"){
        const expected = Object.fromEntries(parseKeyValuePairs(correct));
        const user = Object.fromEntries(
          [...card.querySelectorAll(".var-basic")].map(i=>[i.dataset.key, norm(i.value)])
        );
        const sameKeys = Object.keys(expected).length===Object.keys(user).length &&
                         Object.keys(expected).every(k=>user.hasOwnProperty(k));
        if(!sameKeys) return fail();
        const ok = Object.entries(expected).every(([k,v])=>user[k]===v);
        return ok ? pass() : fail();
      }
      if(type==="ì…ë ¥ ìˆœì„œ ìƒê´€ ì—†ìŒ"){ 
        const users=[...card.querySelectorAll(".order-agnostic")].map(i=>i.value);
        ok=gradeOrderAgnosticList(correct, users);
        return ok ? pass() : fail();
      }

      if(/^ë³€ìˆ˜\s*ëŒ€ì…í˜•\(ë°©ì •ì‹\)\(\d+ê°œ\)$/.test(type)){
        const n=parseInt(type.match(/\((\d+)ê°œ\)/)[1]);
        const varVals=[...card.querySelectorAll(".var-eq")].map(i=>norm(i.value));
        const extraVals=[...card.querySelectorAll(".extra-eq")].map(i=>norm(i.value));
        const corrVals = correct
          .replace(/\s*ë˜ëŠ”\s*/g, ",")
          .match(/=\s*([^,]+)/g)
          ?.map(x => x.replace(/^=\s*/, ""))
          .map(norm) || [];
        const afterEqPart = correct.split(/[^,]+=.+?(?:,|$)/).pop() || "";
        const corrExtras = afterEqPart.split(",").map(norm).filter(Boolean);
        const expected = [...corrVals, ...corrExtras];
        const user=[...varVals,...extraVals];
        if(user.length!==expected.length) return fail();
        return [...user].sort().join(",") === [...expected].sort().join(",") ? pass() : fail();
      }
      if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹)"){
        const inputs=[...card.querySelectorAll(".var-eq")].map(i=>norm(i.value));
        const corr = correct
          .replace(/\s*ë˜ëŠ”\s*/g, ",")
          .match(/=\s*([^,]+)/g)
          ?.map(x => x.replace(/^=\s*/, ""))
          .map(norm) || [];
        if(inputs.length!==corr.length) return fail();
        return ([...inputs].sort().join(",") === [...corr].sort().join(",")) ? pass() : fail();
      }
      if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ì—°ë¦½ë°©ì •ì‹)"){
        const inputs=[...card.querySelectorAll(".var-system")].map(i=>i.value);
        return gradeSystemEquationAsMultiset(correct,inputs)?pass():fail();
      }

      const subInputs=card.querySelectorAll(".subans");
      if(subInputs.length>0){
        const correctParts=correct.replace(/\)\s*/g,") ")
          .split(/\(\d+\)|\([ê°€-ì‚¬]\)/)
          .map(x=>norm(x.replace(/^\)|\)$/g,""))).filter(Boolean);
        const userParts=[...subInputs].map(i=>norm(i.value));
        if(correctParts.length!==userParts.length) return fail();
        return correctParts.every((c,i)=>c===userParts[i])?pass():fail();
      }

      if(type==="ê°ê´€ì‹"){
        const sel=card.querySelector("input[type=radio]:checked")?.value;
        return (sel===correct)?pass():fail();
      }

      if(type==="ê°ê´€ì‹(ë³µìˆ˜í˜•)"){
        const chk=[...card.querySelectorAll("input[type=checkbox]:checked")].map(i=>i.value).join("");
        return (chk===correct)?pass():fail();
      }

      /* ë¬¸ììˆ˜ì‹í˜• */
      if(type==="ë¬¸ììˆ˜ì‹"){
        const user=norm(card.querySelector(".answer-input")?.value.trim()||"");
        const corr=norm(correct);
        return (user===corr)?pass():fail();
      }

      const ans1=card.querySelector(".ans1")?.value.trim()||"";
      const ans2=card.querySelector(".ans2")?.value.trim()||"";

      if(/ëª«\s*:|ë‚˜ë¨¸ì§€\s*:/.test(correct))
        return gradeSpecialPair(correct,ans1,ans2,"ëª«","ë‚˜ë¨¸ì§€")?pass():fail();
      if(/ì‹¤ìˆ˜ë¶€ë¶„\s*:|í—ˆìˆ˜ë¶€ë¶„\s*:/.test(correct))
        return gradeSpecialPair(correct,ans1,ans2,"ì‹¤ìˆ˜ë¶€ë¶„","í—ˆìˆ˜ë¶€ë¶„")?pass():fail();
      if(/ìµœëŒ“ê°’\s*:|ìµœì†Ÿê°’\s*:/.test(correct))
        return gradeSpecialPair(correct,ans1,ans2,"ìµœëŒ“ê°’","ìµœì†Ÿê°’")?pass():fail();

      if(type==="ë“±ì‹í˜•"){
        const user=norm(card.querySelector(".answer-input")?.value.trim()||"");
        return (user===norm(correct))?pass():fail();
      }

      result.textContent="ì±„ì  ë¶ˆê°€ëŠ¥";
      result.className="result-inline";
      return;

      /* ===== ë‚´ë¶€ ìœ í‹¸ ===== */
      function pass(){
        result.textContent="âœ… ì •ë‹µ!";
        result.classList.add("correct");
        btn.classList.add("correct");
        btn.textContent="O";
        disableAll();
      }
      function fail(){
        result.textContent="âŒ ì˜¤ë‹µ..";
        result.classList.add("wrong");
        btn.classList.add("wrong");
        btn.textContent="X";
        disableAll();
      }
      function disableAll(){
        btn.disabled=true;
        card.classList.add("graded");
        card.querySelectorAll("input").forEach(i=>i.disabled=true);
      }
    }

    /* ê°œë³„ ì±„ì  + ëª¨ë‘ì±„ì  ë²„íŠ¼ */
    document.querySelectorAll(".check-btn").forEach(btn=>{
      btn.addEventListener("click",()=>gradeQuestion(btn.closest(".question-card")));
    });

    document.getElementById("check-all").addEventListener("click",()=>{
      document.querySelectorAll(".question-card").forEach(card=>{
        const btn=card.querySelector(".check-btn");
        if(btn && !btn.disabled) gradeQuestion(card);
      });
    });

  }catch(err){
    container.innerHTML="<p style='color:red;'>ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>";
  }
});
</script>
</body>
</html>
