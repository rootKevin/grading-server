<!DOCTYPE html>
<html lang="ko">
  <!-- v1.259550 small-input ê´€ë ¨ ëª¨ë“  ì½”ë“œ ì‚­ì œ -->
  <!-- v1.25955 main.htmlì—ì„œ style ë¶„ë¦¬ -->
  <!-- v1.25954 UI / UX ì •ëˆ -->
  <!-- v1.2580 (í–‰ë ¬ ì œì™¸ ì „ ìœ í˜• MathJax ë¯¸ë¦¬ë³´ê¸° ì ìš© â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2578 (ë‹¨ë‹µí˜• ì±„ì  ê¸°ëŠ¥ ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2577 (í–‰ë ¬í˜•: ì‹œê°ì  ì…ë ¥ì¹¸ ìë™ ìƒì„± â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€)-->
  <!-- v1.2576 (ë¬¸ì¥ ë‹¤ì¤‘ì •ë‹µí˜• ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2575 (í•œê¸€ ììŒí˜• ì±„ì  ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2573 (ìˆ˜ì‹í˜• êµí™˜ë²•ì¹™ ì™„ì „ëŒ€ì‘) -->
  <!-- v1.2572 (ìˆ˜ì‹í˜• êµí™˜ë²•ì¹™ í—ˆìš© ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2571 (ì¸ìˆ˜ë¶„í•´í˜• êµí™˜ê·œì¹™ ì•ˆì •í™”) -->
  <!-- v1.2570 (ì¸ìˆ˜ë¶„í•´í˜• ì±„ì  ê¸°ëŠ¥ ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
  <!-- v1.2569 (ë¬¸ììˆ˜ì‹í˜• ì±„ì  ê¸°ëŠ¥ ì¶”ê°€ â€” ê¸°ì¡´ ê¸°ëŠ¥ ì „ë¶€ ìœ ì§€) -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì±„ì  í˜ì´ì§€</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="styleMain.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <div class="container">
    <h1 id="page-title">ğŸ“˜ ì±„ì  í˜ì´ì§€</h1>

    <!-- ìƒë‹¨ ë²„íŠ¼ ì˜ì—­ -->
    <div class="nav-buttons top-buttons" style="text-align:center; margin-bottom:16px;"></div>

    <div id="question-container">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>

    <!-- í•˜ë‹¨ ë²„íŠ¼ ì˜ì—­ -->
    <div class="bottom-buttons" style="text-align:center; margin-top:20px;">
      <button id="check-all">ì „ë¶€ ì±„ì </button><br />
      <div class="nav-buttons bottom-buttons" style="margin-top:10px;"></div>
    </div>
  </div>
<script>
const API_URL = "https://grading-server-production.up.railway.app/questions";
const MIN_PAGE = 7;      // ì²« ìª½ ë²ˆí˜¸
const MAX_PAGE = 167;    // ë§ˆì§€ë§‰ ìª½ ë²ˆí˜¸

function renderNavButtons(page) {
  page = Number(page);
  const prevBtn = (page > MIN_PAGE)
    ? `<button class="nav-btn" onclick="location.href='main.html?page=${page - 1}'">â¬… ì´ì „ ìª½ìœ¼ë¡œ</button>`
    : "";
  const nextBtn = (page < MAX_PAGE)
    ? `<button class="nav-btn" onclick="location.href='main.html?page=${page + 1}'">ë‹¤ìŒ ìª½ìœ¼ë¡œ â¡</button>`
    : "";
  const backBtn = `<button class="back-btn" onclick="location.href='index.html'">ìª½ ì„ íƒìœ¼ë¡œ</button>`;

  const html = `
    <div class="nav-group">
      ${prevBtn}
      ${backBtn}
      ${nextBtn}
    </div>`;
  return html;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê³µí†µ ì •ê·œí™” â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function normalize(s){
  return (s||"")
    .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, "$1/$2")
    .replace(/\\sqrt\{([^}]+)\}/g, "âˆš$1")
    .replace(/root/gi,"âˆš").replace(/ë£¨íŠ¸/g,"âˆš")
    .replace(/âˆ’/g,"-").replace(/Ã—/g,"*").replace(/\*/g,"")
    .replace(/\s*ë˜ëŠ”\s*(?=[a-zA-Zê°€-í£]+\s*=)/g, ",")
    .replace(/ï¼Œ/g, ",")
    .replace(/\s*,\s*/g, ",")
    .replace(/\s+/g,"")
    .replace(/,$/,"").replace(/^,/,"")
    .trim();
}
/* ì •ë‹µ ë¬¸ìì—´ì„ íŒŒì‹±í•´ í–‰ë ¬ êµ¬ì¡°ë¡œ ë³€í™˜í•˜ê¸° */
function parseMatrixToGrid(str){
  const clean = String(str)
    .replace(/\\begin\{pmatrix\}|\(\\begin\{pmatrix\}\)|\\end\{pmatrix\}|\(|\)|\[|\]/g, "")
    .replace(/,/g, " ")
    .replace(/&/g, " ")
    .replace(/\\\\|\\/g, ";") // í–‰ êµ¬ë¶„
    .replace(/\s+/g, " ")
    .trim();

  const rows = clean.split(";").map(r => r.trim().split(/\s+/).filter(Boolean));
  return rows.filter(r => r.length > 0);
}
/* ì…ë ¥ ìˆœì„œ ìƒê´€ ì—†ìŒ */
function gradeOrderAgnosticList(correct, userList){
  const n=s=>(s||"").replace(/\s+/g,"").trim();
  const C=n(correct).split(",").filter(Boolean);
  const U=userList.map(n);
  if(C.length!==U.length) return false;
  const A=[...C].sort(), B=[...U].sort();
  for(let i=0;i<A.length;i++){if(A[i]!==B[i]) return false;} return true;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê¸°ë³¸ë¬¸ì¥í˜• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeBasicSentence(correct, user){
  const norm = s => (s||"").replace(/\s+/g,"").trim();
  return norm(correct) === norm(user);
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeMultiSentence(correct, user){
  const norm = s => (s||"")
    .replace(/\s+/g,"") // ëª¨ë“  ê³µë°± ì œê±°
    .trim();

  const corrList = norm(correct).split("ë˜ëŠ”").filter(Boolean);
  const userInput = norm(user);

  // ì‚¬ìš©ìê°€ ì—¬ëŸ¬ ë¬¸ì¥ì„ ì…ë ¥í–ˆì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ "ë˜ëŠ”"ìœ¼ë¡œ ë‹¤ì‹œ ë¶„ë¦¬
  const userList = userInput.split("ë˜ëŠ”").filter(Boolean);

  // ì •ë‹µ ëª©ë¡ì´ í•˜ë‚˜ë¼ë„ í¬í•¨ë˜ë©´ ì •ë‹µ
  // (ex: corrList=["A","B","C"], userList=["B","C"] â†’ pass)
  const allCorr = new Set(corrList);
  return userList.every(u => allCorr.has(u));
}

/* í•œê¸€ ììŒí˜• ì±„ì  */
function gradeConsonantAnswer(correct, user){
  const norm = s => (s||"").replace(/\s+/g,"").replace(/,/g,"").trim();
  return norm(correct) === norm(user);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì¸ìˆ˜ë¶„í•´í˜• ì±„ì  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeFactorization(correct, user){
  const splitFactors = s => normalize(String(s)).match(/(?:\([^()]+\)|[^()]+)/g) || [];
  const cParts = splitFactors(correct);
  const uParts = splitFactors(user);
  if(!cParts.length || !uParts.length) return false;

  const isParen = str => str.startsWith("(") && str.endsWith(")");
  const cFront = isParen(cParts[0]) ? "" : cParts[0];
  const uFront = isParen(uParts[0]) ? "" : uParts[0];
  if(cFront !== uFront) return false;

  const cMain = cFront ? cParts.slice(1) : cParts;
  const uMain = uFront ? uParts.slice(1) : uParts;
  if(cMain.length !== uMain.length) return false;

  const sortedC = [...cMain].sort();
  const sortedU = [...uMain].sort();
  for(let i=0;i<sortedC.length;i++){
    if(sortedC[i]!==sortedU[i]) return false;
  }
  return true;
}


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeCommutativeExpression(correct, user){
  // ì „ì²´ ë¬¸ìì—´ ì •ê·œí™”
  const norm = s => (s||"")
    .replace(/âˆ’/g,"-")
    .replace(/\s+/g,"")
    .replace(/\+\-/g,"-")
    .replace(/\-\+/g,"-")
    .replace(/\+\+/g,"+")
    .replace(/\-\-/g,"+")
    .trim();

  // ë¶€í˜¸ í¬í•¨ í•­ ë‹¨ìœ„ ë¶„ë¦¬
  function splitTerms(expr){
    const t = norm(expr);
    // ë§¨ ì•ì— ë¶€í˜¸ê°€ ì—†ìœ¼ë©´ +ë¥¼ ì¶”ê°€
    const prep = /^[+-]/.test(t) ? t : "+" + t;
    // + ë˜ëŠ” - ì•ì—ì„œ ë¶„ë¦¬ (ë¶€í˜¸ ìœ ì§€)
    return prep.split(/(?=[+-])/).map(x => x.trim()).filter(Boolean);
  }

  const corrTerms = splitTerms(correct);
  const userTerms = splitTerms(user);
  if(corrTerms.length !== userTerms.length) return false;

  // í•­ ì •ë ¬ í›„ ë¹„êµ (ìˆœì„œ ë¬´ì‹œ)
  const sortedC = [...corrTerms].sort();
  const sortedU = [...userTerms].sort();

  return JSON.stringify(sortedC) === JSON.stringify(sortedU);
}


/* ê¸°ì¡´ ìœ í‹¸ í•¨ìˆ˜ */
function parseKeyValuePairs(text){
  const pairs=[...String(text).matchAll(/([a-zA-Zê°€-í£]+)\s*=\s*([^,]+)/g)];
  return pairs.map(([,key,val])=>[key.trim(),normalize(val)]);
}
function gradeSpecialPair(correct,user1,user2,key1,key2){
  const norm=normalize;
  const parts=Object.fromEntries(
    correct.replace(/\s+/g,"").split(",").map(p=>p.split(":").map(x=>norm(x)))
  );
  return parts[key1]&&parts[key2]&&norm(parts[key1])===norm(user1)&&norm(parts[key2])===norm(user2);
}
function gradeSystemEquationAsMultiset(correct, inputs){
  const norm=normalize;
  const corrValues=[...correct.matchAll(/=\s*([^,}]+)/g)].map(m=>norm(m[1]));
  const userValues=inputs.map(v=>norm(v));
  if(userValues.length!==corrValues.length) return false;
  return [...userValues].sort().join(",") === [...corrValues].sort().join(",");
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë©”ì¸ ë¡œì§ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
document.addEventListener("DOMContentLoaded", async () => {
  const params = new URLSearchParams(window.location.search);
  const page = params.get("page");
  const container = document.getElementById("question-container");
  const title = document.getElementById("page-title");
  if (!page) {
    container.innerHTML = "<p>âŒ ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤.</p>";
    return;
  }
  title.textContent = `ğŸ“˜ ${page}ìª½ ì±„ì `;

  // ìƒë‹¨Â·í•˜ë‹¨ ë²„íŠ¼ ë Œë”ë§
  document.querySelector(".top-buttons").innerHTML = renderNavButtons(page);
  document.querySelector(".bottom-buttons .nav-buttons").innerHTML = renderNavButtons(page);

  try{
    const res = await fetch(`${API_URL}?page=${page}`);
    const data = await res.json();
    const questions = Object.entries(data)
      .filter(([_, q]) => q.page == page)
      .map(([id, q]) => ({ id, ...q }));

    if (questions.length === 0) {
      container.innerHTML = `<p>âŒ ${page}ìª½ ë¬¸í•­ì´ ì—†ìŠµë‹ˆë‹¤.</p>`;
      return;
    }

    container.innerHTML=questions.map(q=>{
      const type=(q.type||"").trim();
      const ans =(q.ans ||"").trim();
      let inputHTML="";

      if(["í•œê¸€ ììŒ","ë‹¨ë‹µí˜•","ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©)","ë¬¸ììˆ˜ì‹","ë“±ì‹í˜•","ê¸°ë³¸ë¬¸ì¥","ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€)","ì¸ìˆ˜ë¶„í•´"].includes(type)){
          inputHTML=`<input type="text" class="answer-input" />`;
      }
      /* í–‰ë ¬ */
      else if(type==="í–‰ë ¬"){
        const matrix = parseMatrixToGrid(ans);
        const rows = matrix.length;
        const cols = matrix[0]?.length || 0;

        inputHTML = `
          <div class="matrix-input" data-rows="${rows}" data-cols="${cols}">
            ${matrix.map((row, i) => `
              <div class="matrix-row">
                ${row.map((_, j) =>
                  `<input type="text" class="matrix-cell" data-row="${i}" data-col="${j}" />`
                ).join("")}
              </div>
            `).join("")}
          </div>`;
      }
      else if(type==="ì…ë ¥ ìˆœì„œ ìƒê´€ ì—†ìŒ"){
        inputHTML='<div class="multi-inputs">'+Array.from({length:n},(_,i)=>`<div class="formula-input"><input type="text" class="order-agnostic" data-index="${i}" placeholder="" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>`).join("")+'</div>';
      }
      /* â‘¡ ê¸°ë³¸ ë³€ìˆ˜ ëŒ€ì…í˜• */
      else if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•"){
        const labels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        inputHTML=`<div class="sub-group"><div class="var-inputs">${
          labels.map(l=>`<div class="sub-input"><label>${l}</label><div class="formula-input"><input type="text" class="var-basic" data-key="${l}" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div></div>`).join("")
        }</div></div>`;
      }
      /* â‘¢ ë³€ìˆ˜ ëŒ€ì…í˜•(ì—°ë¦½ë°©ì •ì‹) */
      else if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ì—°ë¦½ë°©ì •ì‹)"){
        const labels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        inputHTML=`<div class="sub-group"><div class="var-inputs">${
          labels.map(l=>`<div class="sub-input"><label>${l}</label><div class="formula-input"><input type="text" class="var-system" data-key="${l}" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div></div>`).join("")
        }</div></div>`;
      }
      /* â‘£ ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹)(nê°œ) */
      else if(/^ë³€ìˆ˜\s*ëŒ€ì…í˜•\(ë°©ì •ì‹\)\(\d+ê°œ\)$/.test(type)){
        const n=parseInt(type.match(/\((\d+)ê°œ\)/)[1]);
        const baseLabels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        const total=baseLabels.length + n;
        inputHTML=`<div class="var-inputs">` +
          baseLabels.map(v=>`<label>${v}</label><div class="formula-input"><input type="text" class="var-eq" data-key="${v}" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>`).join("") +
          Array.from({length:n}).map(()=>`<div class="formula-input"><input type="text" class="extra-eq" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>`).join("") +
          `</div>`;
      }
      /* â‘¤ ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹) */
      else if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹)"){
        const labels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        inputHTML=`<div class="sub-group"><div class="var-inputs">${
          labels.map(l=>`<div class="sub-input"><label>${l}</label><div class="formula-input"><input type="text" class="var-eq" data-key="${l}" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div></div>`).join("")
        }</div></div>`;
      }
      /* â‘¦ ì†Œë¬¸í•­í˜• */
else if(/\(\d+\)|\([ê°€-ì‚¬]\)/.test(ans)){
  const tokens = ans.match(/\((\d+|[ê°€-ì‚¬])\)/g) || [];

  // âœ… ì†Œë¬¸í•­ ë¼ë²¨ + ì…ë ¥ì¹¸ ë¬¶ìŒ êµ¬ì¡° ì ìš©
  inputHTML = `
    <div class="sub-group">
      ${tokens.map((t, i) => `
        <div class="sub-input">
          <label>${t}</label>
          <div class="formula-input">
            <input type="text" class="subans" data-index="${i}" />
            <div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div>
          </div>
        </div>
      `).join("")}
    </div>
  `;
}
      /* â‘§ ê°ê´€ì‹ / ë³µìˆ˜í˜• */
      else if(type==="ê°ê´€ì‹"){
        const opts=["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"];
        inputHTML=`<div class="choices">${
          opts.map(o=>`<label><input type="radio" name="${q.id}" value="${o}">${o}</label>`).join("")
        }</div>`;
      }
      else if(type==="ê°ê´€ì‹(ë³µìˆ˜í˜•)"){
        const opts=["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"];
        inputHTML=`<div class="choices">${
          opts.map(o=>`<label><input type="checkbox" name="${q.id}" value="${o}">${o}</label>`).join("")
        }</div>`;
      }
      else if(type==="ì£¼ê´€ì‹(íŠ¹ìˆ˜)") {
        /* â‘¨ ë‹¨ë‹µí˜• / íŠ¹ìˆ˜í˜• */
        if(/ëª«\s*:|ë‚˜ë¨¸ì§€\s*:/.test(ans)){
          inputHTML=`<div class="dual-inputs"><label>ëª«</label><div class="formula-input"><input type="text" class="ans1" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>
            <label>ë‚˜ë¨¸ì§€</label><div class="formula-input"><input type="text" class="ans2" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div></div>`;
        }else if(/ì‹¤ìˆ˜ë¶€ë¶„\s*:|í—ˆìˆ˜ë¶€ë¶„\s*:/.test(ans)){
          inputHTML=`<div class="dual-inputs"><label>ì‹¤ìˆ˜ë¶€ë¶„</label><div class="formula-input"><input type="text" class="ans1" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>
            <label>í—ˆìˆ˜ë¶€ë¶„</label><div class="formula-input"><input type="text" class="ans2" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div></div>`;
        }else if(/ìµœëŒ“ê°’\s*:|ìµœì†Ÿê°’\s*:/.test(ans)){
          inputHTML=`<div class="dual-inputs"><label>ìµœëŒ“ê°’</label><div class="formula-input"><input type="text" class="ans1" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>
            <label>ìµœì†Ÿê°’</label><div class="formula-input"><input type="text" class="ans2" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div></div>`;
        }
      }
      else{
        inputHTML=`<input type="text" class="answer-input disabled" value="ì±„ì  ë¶ˆê°€ëŠ¥ ìœ í˜•" disabled />`;
      }
      // --- ì…ë ¥ì¹¸ ìƒì„± ì´í›„ ---
      if(!["ê°ê´€ì‹","ê°ê´€ì‹(ë³µìˆ˜í˜•)"].includes(type)){
        inputHTML = inputHTML.replace(
          /(<input[^>]*class="[^"]*answer-input[^"]*"[^>]*>)/g,
          `<div class="formula-input">$1<div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>`
        );
      }
      return `
        <div class="question-card" data-id="${q.id}">
          <div class="question-line">
            <h3>${q.id.replace("q","")}ë²ˆ</h3>
            ${inputHTML}
            <button class="check-btn">ì±„ì </button>
            <span class="result-inline"></span>
          </div>
          <input type="hidden" class="correct-answer" value="${ans}" />
          <input type="hidden" class="answer-type" value="${type}" />
        </div>`;

    }).join("");

    /* ===== ì±„ì  ë¡œì§ ===== */
    function gradeQuestion(card){
      const btn=card.querySelector(".check-btn");
      const result=card.querySelector(".result-inline");
      const correct=card.querySelector(".correct-answer").value.trim();
      const type=card.querySelector(".answer-type").value.trim();
      const norm=normalize;
      // --- ë‹¨ë‹µí˜• ì±„ì 
      if(type==="ë‹¨ë‹µí˜•"){
        const user=normalize(card.querySelector(".answer-input")?.value.trim()||"");
        const corr=normalize(correct);
        return (user===corr)?pass():fail();
      }
      // --- í–‰ë ¬ ì±„ì 
      if(type==="í–‰ë ¬"){
          const corr = parseMatrixToGrid(correct);
          const user = [];
          const rows = corr.length;
          const cols = corr[0].length;

          for(let i=0;i<rows;i++){
            const rowVals=[];
            for(let j=0;j<cols;j++){
              const val=normalize(card.querySelector(`.matrix-cell[data-row="${i}"][data-col="${j}"]`)?.value||"");
              rowVals.push(val);
            }
            user.push(rowVals);
          }

          const sameSize = user.length===corr.length && user.every((r,i)=>r.length===corr[i].length);
          if(!sameSize) return fail();

          const ok = user.every((r,i)=>r.every((v,j)=>normalize(v)===normalize(corr[i][j])));
          return ok ? pass() : fail();
      }

      // --- ê¸°ë³¸ë¬¸ì¥ ì±„ì 
      if(type==="ê¸°ë³¸ë¬¸ì¥"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeBasicSentence(correct,user)?pass():fail();
      }
            // --- ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€) ì±„ì 
      if(type==="ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€)"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeMultiSentence(correct,user)?pass():fail();
      }

      // --- í•œê¸€ ììŒí˜• ì±„ì 
      if(type==="í•œê¸€ ììŒ") {
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeConsonantAnswer(correct,user)?pass():fail();
      }
      // --- ì¸ìˆ˜ë¶„í•´í˜• ì±„ì  ---
      if(type==="ì¸ìˆ˜ë¶„í•´"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeFactorization(correct,user)?pass():fail();
      }

      /* âœ… ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©) */
      if(type==="ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©)"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeCommutativeExpression(correct,user)?pass():fail();
      }

      // --- ê¸°ì¡´ ìœ í˜•ë“¤ ---
      if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•"){
        const expected = Object.fromEntries(parseKeyValuePairs(correct));
        const user = Object.fromEntries(
          [...card.querySelectorAll(".var-basic")].map(i=>[i.dataset.key, norm(i.value)])
        );
        const sameKeys = Object.keys(expected).length===Object.keys(user).length &&
                         Object.keys(expected).every(k=>user.hasOwnProperty(k));
        if(!sameKeys) return fail();
        const ok = Object.entries(expected).every(([k,v])=>user[k]===v);
        return ok ? pass() : fail();
      }
      if(type==="ì…ë ¥ ìˆœì„œ ìƒê´€ ì—†ìŒ"){ 
        const users=[...card.querySelectorAll(".order-agnostic")].map(i=>i.value);
        ok=gradeOrderAgnosticList(correct, users);
        return ok ? pass() : fail();
      }

      if(/^ë³€ìˆ˜\s*ëŒ€ì…í˜•\(ë°©ì •ì‹\)\(\d+ê°œ\)$/.test(type)){
        const n=parseInt(type.match(/\((\d+)ê°œ\)/)[1]);
        const varVals=[...card.querySelectorAll(".var-eq")].map(i=>norm(i.value));
        const extraVals=[...card.querySelectorAll(".extra-eq")].map(i=>norm(i.value));
        const corrVals = correct
          .replace(/\s*ë˜ëŠ”\s*/g, ",")
          .match(/=\s*([^,]+)/g)
          ?.map(x => x.replace(/^=\s*/, ""))
          .map(norm) || [];
        const afterEqPart = correct.split(/[^,]+=.+?(?:,|$)/).pop() || "";
        const corrExtras = afterEqPart.split(",").map(norm).filter(Boolean);
        const expected = [...corrVals, ...corrExtras];
        const user=[...varVals,...extraVals];
        if(user.length!==expected.length) return fail();
        return [...user].sort().join(",") === [...expected].sort().join(",") ? pass() : fail();
      }
      if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹)"){
        const inputs=[...card.querySelectorAll(".var-eq")].map(i=>norm(i.value));
        const corr = correct
          .replace(/\s*ë˜ëŠ”\s*/g, ",")
          .match(/=\s*([^,]+)/g)
          ?.map(x => x.replace(/^=\s*/, ""))
          .map(norm) || [];
        if(inputs.length!==corr.length) return fail();
        return ([...inputs].sort().join(",") === [...corr].sort().join(",")) ? pass() : fail();
      }
      if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ì—°ë¦½ë°©ì •ì‹)"){
        const inputs=[...card.querySelectorAll(".var-system")].map(i=>i.value);
        return gradeSystemEquationAsMultiset(correct,inputs)?pass():fail();
      }

      const subInputs=card.querySelectorAll(".subans");
      if(subInputs.length>0){
        const correctParts=correct.replace(/\)\s*/g,") ")
          .split(/\(\d+\)|\([ê°€-ì‚¬]\)/)
          .map(x=>norm(x.replace(/^\)|\)$/g,""))).filter(Boolean);
        const userParts=[...subInputs].map(i=>norm(i.value));
        if(correctParts.length!==userParts.length) return fail();
        return correctParts.every((c,i)=>c===userParts[i])?pass():fail();
      }

      if(type==="ê°ê´€ì‹"){
        const sel=card.querySelector("input[type=radio]:checked")?.value;
        return (sel===correct)?pass():fail();
      }

      if(type==="ê°ê´€ì‹(ë³µìˆ˜í˜•)"){
        const chk=[...card.querySelectorAll("input[type=checkbox]:checked")].map(i=>i.value).join("");
        return (chk===correct)?pass():fail();
      }

      /* ë¬¸ììˆ˜ì‹í˜• */
      if(type==="ë¬¸ììˆ˜ì‹"){
        const user=norm(card.querySelector(".answer-input")?.value.trim()||"");
        const corr=norm(correct);
        return (user===corr)?pass():fail();
      }

      const ans1=card.querySelector(".ans1")?.value.trim()||"";
      const ans2=card.querySelector(".ans2")?.value.trim()||"";

      if(/ëª«\s*:|ë‚˜ë¨¸ì§€\s*:/.test(correct))
        return gradeSpecialPair(correct,ans1,ans2,"ëª«","ë‚˜ë¨¸ì§€")?pass():fail();
      if(/ì‹¤ìˆ˜ë¶€ë¶„\s*:|í—ˆìˆ˜ë¶€ë¶„\s*:/.test(correct))
        return gradeSpecialPair(correct,ans1,ans2,"ì‹¤ìˆ˜ë¶€ë¶„","í—ˆìˆ˜ë¶€ë¶„")?pass():fail();
      if(/ìµœëŒ“ê°’\s*:|ìµœì†Ÿê°’\s*:/.test(correct))
        return gradeSpecialPair(correct,ans1,ans2,"ìµœëŒ“ê°’","ìµœì†Ÿê°’")?pass():fail();

      if(type==="ë“±ì‹í˜•"){
        const user=norm(card.querySelector(".answer-input")?.value.trim()||"");
        return (user===norm(correct))?pass():fail();
      }

      result.textContent="ì±„ì  ë¶ˆê°€ëŠ¥";
      result.className="result-inline";
      return;

      /* ===== ë‚´ë¶€ ìœ í‹¸ ===== */
      function pass(){
        result.textContent="âœ… ì •ë‹µ!";
        result.classList.add("correct");
        btn.classList.add("correct");
        btn.textContent="O";
        disableAll();
      }
      function fail(){
        result.textContent="âŒ ì˜¤ë‹µ..";
        result.classList.add("wrong");
        btn.classList.add("wrong");
        btn.textContent="X";
        disableAll();
      }
      function disableAll(){
        btn.disabled=true;
        card.classList.add("graded");
        card.querySelectorAll("input").forEach(i=>i.disabled=true);
      }
    }

    /* ê°œë³„ ì±„ì  + ëª¨ë‘ì±„ì  ë²„íŠ¼ */
    document.querySelectorAll(".check-btn").forEach(btn=>{
      btn.addEventListener("click",()=>gradeQuestion(btn.closest(".question-card")));
    });

    document.getElementById("check-all").addEventListener("click",()=>{
      document.querySelectorAll(".question-card").forEach(card=>{
        const btn=card.querySelector(".check-btn");
        if(btn && !btn.disabled) gradeQuestion(card);
      });
    });
    document.addEventListener("input", e=>{
      // âœ… í–‰ë ¬í˜•ë§Œ ì œì™¸, ë‚˜ë¨¸ì§€ ëª¨ë“  text input ëŒ€ìƒ
      if(e.target.tagName === "INPUT" && e.target.type === "text" && !e.target.classList.contains("matrix-cell")){
        const val = e.target.value.trim();
        const preview = e.target.closest(".formula-input")?.querySelector(".math-preview");
        if(preview){
          preview.innerHTML = val ? `\\(${val}\\)` : "";
          MathJax.typesetPromise([preview]);
        }
      }
    });
  }catch(err){
    container.innerHTML="<p style='color:red;'>ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>";
  }
});
</script>
</body>
</html>
