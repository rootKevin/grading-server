<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì±„ì  í˜ì´ì§€</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="styleMain.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <nav class="navbar">
    <a href="dashboard.html">ğŸ  í™ˆ</a>
    <a href="workbook-pages.html">ğŸ“˜ ìª½ ì„ íƒ</a>

    <div class="user-name">ğŸ‘¤ ì–‘ì§€ìš°</div>
    <button class="logout-btn" onclick="logout()">ğŸšª ë¡œê·¸ì•„ì›ƒ</button>
  </nav>
  <div class="container">
    <h1 id="page-title">ğŸ“˜ ì±„ì  í˜ì´ì§€</h1>

    <!-- ìƒë‹¨ ë²„íŠ¼ ì˜ì—­ -->
    <div class="nav-buttons top-buttons" style="text-align:center; margin-bottom:16px;"></div>

    <div id="question-container">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>

    <!-- í•˜ë‹¨ ë²„íŠ¼ ì˜ì—­ -->
    <div class="bottom-buttons" style="text-align:center; margin-top:20px;">
      <div id="wrong-list" style="color:red; margin:12px 0; font-weight:bold;"></div>
      <button id="check-all">ì „ë¶€ ì±„ì </button><br />
      <div class="nav-buttons bottom-buttons" style="margin-top:10px;"></div>
    </div>
  </div>
<script>
const API_BASE = "https://grading-server-production.up.railway.app";
let MIN_PAGE = null;
let MAX_PAGE = null;

let wrongNumbers = [];

function renderNavButtons(page, workbook) {
  page = Number(page);

  const prevBtn = (page > MIN_PAGE)
    ? `<button class="nav-btn"
        onclick="location.href='grading.html?workbook=${encodeURIComponent(workbook)}&page=${page - 1}'">
        â¬… ì´ì „ ìª½ìœ¼ë¡œ</button>`
    : "";

  const nextBtn = (page < MAX_PAGE)
    ? `<button class="nav-btn"
        onclick="location.href='grading.html?workbook=${encodeURIComponent(workbook)}&page=${page + 1}'">
        ë‹¤ìŒ ìª½ìœ¼ë¡œ â¡</button>`
    : "";

  return `<div class="nav-group">${prevBtn}${nextBtn}</div>`;
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê³µí†µ ì •ê·œí™” â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function normalize(s){
  let t = (s || "").trim();

  // 0. MathJax wrapper ì œê±° \( ... \)
  t = t.replace(/\\\(|\\\)/g, "");

  // 1. LaTeX \frac{...}{...} (ì¤‘ì²© ì¤‘ê´„í˜¸ í¬í•¨) â†’ (ë¶„ì)/(ë¶„ëª¨)
  t = (function convertFrac(str){
    let out = [];
    let i = 0, n = str.length;

    while (i < n) {
      // \frac ë°œê²¬
      if (str[i] === "\\" && str.startsWith("\\frac", i)) {
        i += 5; // "\frac" ê±´ë„ˆëœ€

        // ê³µë°± ìŠ¤í‚µ
        while (i < n && /\s/.test(str[i])) i++;

        // ë¶„ì ì‹œì‘ì€ ë°˜ë“œì‹œ '{' ë¼ê³  ê°€ì •
        if (i >= n || str[i] !== "{") {
          out.push("\\frac");
          continue;
        }

        // --- ë¶„ì íŒŒì‹± (ì¤‘ì²© ì¤‘ê´„í˜¸ í—ˆìš©) ---
        i++; // '{' ë’¤ë¡œ
        let depth = 0;
        const startNum = i;
        while (i < n) {
          const c = str[i];
          if (c === "{") depth++;
          else if (c === "}") {
            if (depth === 0) break; // ë¶„ì ë
            depth--;
          }
          i++;
        }
        const num = str.slice(startNum, i); // ë°”ê¹¥ {} ì œì™¸ëœ ë¶„ì
        i++; // '}' ë’¤ë¡œ

        // ê³µë°± ìŠ¤í‚µ
        while (i < n && /\s/.test(str[i])) i++;

        // --- ë¶„ëª¨ íŒŒì‹± ---
        if (i >= n || str[i] !== "{") {
          // ì´ìƒí•œ í˜•íƒœë©´ ê·¸ëƒ¥ ì›ë¬¸ ì¼ë¶€ë¥¼ ë‚¨ê¹€
          out.push("\\frac{" + num + "}");
          continue;
        }
        i++; // '{' ë’¤ë¡œ
        depth = 0;
        const startDen = i;
        while (i < n) {
          const c = str[i];
          if (c === "{") depth++;
          else if (c === "}") {
            if (depth === 0) break; // ë¶„ëª¨ ë
            depth--;
          }
          i++;
        }
        const den = str.slice(startDen, i);
        i++; // '}' ë’¤ë¡œ

        // ë¶„ì/ë¶„ëª¨ë¥¼ (num)/(den) í˜•íƒœë¡œ ë³€í™˜
        out.push(num + "/" + den);
      } else {
        out.push(str[i]);
        i++;
      }
    }
    return out.join("");
  })(t);

  // 2. ìœ ë‹ˆì½”ë“œ ê¸°í˜¸ í†µì¼ + ê³µë°± ì œê±°
  t = t.replace(/ï¼Œ/g, ",")
       .replace(/âˆ’/g, "-")
       .replace(/\s+/g, "");

  // 3. Â± ì²˜ë¦¬
  t = t.replace(/\\pm/g, "Â±").replace(/Â±/g, "Â±");

  // 4. sqrt / root / ë£¨íŠ¸ â†’ âˆš ë¡œ ë³€í™˜
  t = t.replace(/\\sqrt\{([^}]+)\}/g, "âˆš$1")
       .replace(/\{âˆš([^}]+)\}/g, "âˆš$1")         // {âˆš5} â†’ âˆš5
       .replace(/root\(?([^)]+)\)?/gi, "âˆš$1")
       .replace(/ë£¨íŠ¸\s*([0-9a-zA-Z]+)/g, "âˆš$1");

  // 5. ë” ì´ìƒ ì˜ë¯¸ ì—†ëŠ” ì¤‘ê´„í˜¸ ì œê±° ({2*âˆš3} ê°™ì€ ê²ƒ)
  t = t.replace(/[{}]/g, "");

  // 6. âˆš ë°”ë¡œ ë’¤ i ë¶™ëŠ” ê²½ìš° ê³±ì…ˆí‘œì‹œ ì¶”ê°€: âˆš3i â†’ âˆš3*i
  t = t.replace(/âˆš([^+*/()\-]*)i/g, "âˆš$1*i");

  // 7. ê³± ìƒëµ ë³´ì™„ (2a, a(b+1), )(2 ë“±)
  t = t.replace(/(\d)([a-zA-Zâˆši])/g, "$1*$2")
       .replace(/([a-zA-Zâˆši])\(/g, "$1*(")
       .replace(/\)([a-zA-Zâˆši\d])/g, ")*$1");

  // 8. ì¤‘ë³µ ê³±ì…ˆ ê¸°í˜¸ ì •ë¦¬
  t = t.replace(/\*\*/g, "*");

  // âŒ ë” ì´ìƒ ì–‘ë ê´„í˜¸ í†µì§¸ë¡œ ìë¥´ì§€ ì•ŠëŠ”ë‹¤
  // if (t.startsWith("(") && t.endsWith(")")) { ... } ì œê±°

  return t.trim();
}
function normalizeFactorization(s){
  let t = (s || "").trim();

  // 1. \(...\) wrapper ì œê±°
  t = t.replace(/\\\(|\\\)/g, "");

  // 2. ìœ ë‹ˆì½”ë“œ ê¸°í˜¸ í†µì¼
  t = t.replace(/ï¼Œ/g, ",").replace(/âˆ’/g, "-");

  // 3. \pm â†’ Â±
  t = t.replace(/\\pm/g, "Â±");

  // 4. ë£¨íŠ¸ ê´„í˜¸ ë‚´ë¶€ì˜ LaTeXëŠ” âˆšë¡œ ë³€í™˜í•˜ë˜ ì¤‘ê´„í˜¸ ìœ ì§€
  //    ë‹¨, inner "\sqrt{5}" â†’ "âˆš5"ë¡œ ë°”ê¾¸ë¯€ë¡œ ì—¬ê¸°ë§Œ ìµœì†Œ ë³€í™˜
  t = t.replace(/\\sqrt\{5\}/g, "âˆš5")
       .replace(/\\sqrt\{([^}]+)\}/g, "âˆš$1");

  return t;
}
/* ì •ë‹µ ë¬¸ìì—´ì„ íŒŒì‹±í•´ í–‰ë ¬ êµ¬ì¡°ë¡œ ë³€í™˜í•˜ê¸° */
function parseMatrixToGrid(str){
  const clean = String(str)
    .replace(/\\begin\{pmatrix\}|\(\\begin\{pmatrix\}\)|\\end\{pmatrix\}|\(|\)|\[|\]/g, "")
    .replace(/,/g, " ")
    .replace(/&/g, " ")
    .replace(/\\\\|\\/g, ";") // í–‰ êµ¬ë¶„
    .replace(/\s+/g, " ")
    .trim();

  const rows = clean.split(";").map(r => r.trim().split(/\s+/).filter(Boolean));
  return rows.filter(r => r.length > 0);
}
/* ì…ë ¥ ìˆœì„œ ìƒê´€ ì—†ìŒ */
function gradeOrderAgnosticList(correct, userList){
  const n=s=>(s||"").replace(/\s+/g,"").trim();
  const C=n(correct).split(",").filter(Boolean);
  const U=userList.map(n);
  if(C.length!==U.length) return false;
  const A=[...C].sort(), B=[...U].sort();
  for(let i=0;i<A.length;i++){if(A[i]!==B[i]) return false;} return true;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê¸°ë³¸ë¬¸ì¥í˜• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeBasicSentence(correct, user){
  const norm = s => (s||"").replace(/\s+/g,"").trim();
  return norm(correct) === norm(user);
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeMultiSentence(correct, user){
  const norm = s => (s||"")
    .replace(/\s+/g,"") // ëª¨ë“  ê³µë°± ì œê±°
    .trim();

  const corrList = norm(correct).split("ë˜ëŠ”").filter(Boolean);
  const userInput = norm(user);

  // ì‚¬ìš©ìê°€ ì—¬ëŸ¬ ë¬¸ì¥ì„ ì…ë ¥í–ˆì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ "ë˜ëŠ”"ìœ¼ë¡œ ë‹¤ì‹œ ë¶„ë¦¬
  const userList = userInput.split("ë˜ëŠ”").filter(Boolean);

  // ì •ë‹µ ëª©ë¡ì´ í•˜ë‚˜ë¼ë„ í¬í•¨ë˜ë©´ ì •ë‹µ
  // (ex: corrList=["A","B","C"], userList=["B","C"] â†’ pass)
  const allCorr = new Set(corrList);
  return userList.every(u => allCorr.has(u));
}

/* í•œê¸€ ììŒí˜• ì±„ì  */
function gradeConsonantAnswer(correct, user){
  const norm = s => (s||"").replace(/\s+/g,"").replace(/,/g,"").trim();
  return norm(correct) === norm(user);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì¸ìˆ˜ë¶„í•´í˜• ì±„ì  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeFactorization(correct, user){
  const C = normalizeFactorization(correct);
  const U = normalizeFactorization(user);

  const cParts = C.match(/\([^()]+\)/g) || []; // â† âœ… í•­ ì¶”ì¶œ
  const uParts = U.match(/\([^()]+\)/g) || [];

  if(cParts.length !== uParts.length) return false;

  const sortedC = [...cParts].sort();
  const sortedU = [...uParts].sort();

  return JSON.stringify(sortedC) === JSON.stringify(sortedU);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function gradeCommutativeExpression(correct, user){
  const C = normalize(correct);
  const U = normalize(user);

  const corrTerms = splitTerms(C);
  const userTerms = splitTerms(U);

  if(corrTerms.length !== userTerms.length) return false;
  return JSON.stringify([...corrTerms].sort()) === JSON.stringify([...userTerms].sort());
}

function splitTerms(expr){
  const front = /^[+-]/.test(expr) ? expr : "+" + expr;
  return front.split(/(?=[+-])/).filter(Boolean);
}

/* ê¸°ì¡´ ìœ í‹¸ í•¨ìˆ˜ */
function parseKeyValuePairs(text){
  const pairs=[...String(text).matchAll(/([a-zA-Zê°€-í£]+)\s*=\s*([^,]+)/g)];
  return pairs.map(([,key,val])=>[key.trim(),normalize(val)]);
}
function gradeSpecialPair(correct,user1,user2,key1,key2){
  const norm=normalize;
  const parts=Object.fromEntries(
    correct.replace(/\s+/g,"").split(",").map(p=>p.split(":").map(x=>norm(x)))
  );
  return parts[key1]&&parts[key2]&&norm(parts[key1])===norm(user1)&&norm(parts[key2])===norm(user2);
}
function gradeSystemEquationAsMultiset(correct, inputs){
  const norm=normalize;
  const corrValues=[...correct.matchAll(/=\s*([^,}]+)/g)].map(m=>norm(m[1]));
  const userValues=inputs.map(v=>norm(v));
  if(userValues.length!==corrValues.length) return false;
  return [...userValues].sort().join(",") === [...corrValues].sort().join(",");
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë©”ì¸ ë¡œì§ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
document.addEventListener("DOMContentLoaded", async () => {
  const params = new URLSearchParams(window.location.search);
  const page = params.get("page");
  const workbook = params.get("workbook") || localStorage.getItem("workbook");
  const container = document.getElementById("question-container");
  const title = document.getElementById("page-title");
 if (!page || !workbook) {
    container.innerHTML = "<p>âŒ ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤.</p>";
    return;
  }
  title.textContent = `ğŸ“˜ ${page}ìª½ ì±„ì `;

  /* âœ… 1. êµì¬ë³„ í˜ì´ì§€ ë²”ìœ„ ê°€ì ¸ì˜¤ê¸° */
  const rangeRes = await fetch(
    `${API_BASE}/page-range?workbook=${encodeURIComponent(workbook)}`
  );
  const range = await rangeRes.json();

  MIN_PAGE = range.minPage;
  MAX_PAGE = range.maxPage;

  // ìƒë‹¨Â·í•˜ë‹¨ ë²„íŠ¼ ë Œë”ë§
  document.querySelector(".top-buttons").innerHTML = renderNavButtons(page, workbook);
  document.querySelector(".bottom-buttons .nav-buttons").innerHTML = renderNavButtons(page,workbook);

  try{
    const res = await fetch(`${API_BASE}/questions?workbook=${encodeURIComponent(workbook)}&page=${page}`);
    const data = await res.json();
    const questions = Object.entries(data)
      .filter(([_, q]) => q.page == page)
      .map(([id, q]) => ({ id, ...q }));

    if (questions.length === 0) {
      container.innerHTML = `<p>âŒ ${page}ìª½ ë¬¸í•­ì´ ì—†ìŠµë‹ˆë‹¤.</p>`;
      return;
    }

    container.innerHTML=questions.map(q=>{
      const type=(q.type||"").trim();
      const ans =(q.ans ||"").trim();
      const option1=(q.gradingOption1||"").trim();
      let inputHTML="";
      /*********************** ì±„ì  ë¶ˆê°€ ***********************
      if(["í•œê¸€ ììŒ","ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©)","ë¬¸ììˆ˜ì‹","ë“±ì‹í˜•","ê¸°ë³¸ë¬¸ì¥","ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€)","ì¸ìˆ˜ë¶„í•´"].includes(type)){
          inputHTML=`<input type="text" class="answer-input" />`;
      }
      *********************************************************/
      if(type==="ë‹¨ë‹µí˜•") {
        if(option1 === "ë‹¨í•­ì‹") {
          inputHTML=`<input type="text" class="answer-input" />`;
        }
        else {
          inputHTML=`<input type="text" class="answer-input disabled" value="ì±„ì  ë¶ˆê°€ëŠ¥ ìœ í˜•" disabled />`;
        }
      }
      /* â‘§ ê°ê´€ì‹ / ë³µìˆ˜í˜• */
      else if(type==="ê°ê´€ì‹"){
          if(option1==="ë³µìˆ˜í˜•"){
          const opts=["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"];
          inputHTML=`<div class="choices">${
            opts.map(o=>`<label><input type="checkbox" name="${q.id}" value="${o}">${o}</label>`).join("")
          }</div>`;          
        }
        else {
          const opts=["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"];
          inputHTML=`<div class="choices">${
            opts.map(o=>`<label><input type="radio" name="${q.id}" value="${o}">${o}</label>`).join("")
          }</div>`;
        }
      }
      
      /* í–‰ë ¬ */
      /*********************** ì±„ì  ë¶ˆê°€ ***********************
      else if(type==="í–‰ë ¬"){
        const matrix = parseMatrixToGrid(ans);
        const rows = matrix.length;
        const cols = matrix[0]?.length || 0;

        inputHTML = `
          <div class="matrix-input" data-rows="${rows}" data-cols="${cols}">
            ${matrix.map((row, i) => `
              <div class="matrix-row">
                ${row.map((_, j) =>
                  `<input type="text" class="matrix-cell" data-row="${i}" data-col="${j}" />`
                ).join("")}
              </div>
            `).join("")}
          </div>`;
      }
      *********************************************************/
      /* â‘¡ ê¸°ë³¸ ë³€ìˆ˜ ëŒ€ì…í˜• */
      /*********************** ì±„ì  ë¶ˆê°€ ***********************
      else if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•"){
        const labels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        inputHTML=`<div class="sub-group"><div class="var-inputs">${
          labels.map(l=>`<div class="sub-input"><label>${l}</label><div class="formula-input"><input type="text" class="var-basic" data-key="${l}" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div></div>`).join("")
        }</div></div>`;
      }
      *********************************************************/
      /* â‘¢ ë³€ìˆ˜ ëŒ€ì…í˜•(ì—°ë¦½ë°©ì •ì‹) */
      /*********************** ì±„ì  ë¶ˆê°€ ***********************
      else if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ì—°ë¦½ë°©ì •ì‹)"){
        const labels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        inputHTML=`<div class="sub-group"><div class="var-inputs">${
          labels.map(l=>`<div class="sub-input"><label>${l}</label><div class="formula-input"><input type="text" class="var-system" data-key="${l}" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div></div>`).join("")
        }</div></div>`;
      }
      *********************************************************/
      /* â‘£ ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹)(nê°œ) */
      /*********************** ì±„ì  ë¶ˆê°€ ***********************
      else if(/^ë³€ìˆ˜\s*ëŒ€ì…í˜•\(ë°©ì •ì‹\)\(\d+ê°œ\)$/.test(type)){
        const n=parseInt(type.match(/\((\d+)ê°œ\)/)[1]);
        const baseLabels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        const total=baseLabels.length + n;
        inputHTML=`<div class="var-inputs">` +
          baseLabels.map(v=>`<label>${v}</label><div class="formula-input"><input type="text" class="var-eq" data-key="${v}" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>`).join("") +
          Array.from({length:n}).map(()=>`<div class="formula-input"><input type="text" class="extra-eq" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>`).join("") +
          `</div>`;
      }
      *********************************************************/
      /* â‘¤ ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹) */
      /*********************** ì±„ì  ë¶ˆê°€ ***********************
      else if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹)"){
        const labels=[...ans.matchAll(/([a-zA-Zê°€-í£]+)\s*=/g)].map(m=>m[1]);
        inputHTML=`<div class="sub-group"><div class="var-inputs">${
          labels.map(l=>`<div class="sub-input"><label>${l}</label><div class="formula-input"><input type="text" class="var-eq" data-key="${l}" /><div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div></div>`).join("")
        }</div></div>`;
      }
      *********************************************************/
      /* â‘¦ ì†Œë¬¸í•­í˜• */
      /*********************** ì±„ì  ë¶ˆê°€ ***********************
      else if(/\(\d+\)|\([ê°€-ì‚¬]\)/.test(ans)){
        const tokens = ans.match(/\((\d+|[ê°€-ì‚¬])\)/g) || [];
        // âœ… ì†Œë¬¸í•­ ë¼ë²¨ + ì…ë ¥ì¹¸ ë¬¶ìŒ êµ¬ì¡° ì ìš©
        inputHTML = `
          <div class="sub-group">
            ${tokens.map((t, i) => `
              <div class="sub-input">
                <label>${t}</label>
                <div class="formula-input">
                  <input type="text" class="subans" data-index="${i}" />
                  <div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div>
                </div>
              </div>
            `).join("")}
          </div>
        `;
      }
      *********************************************************/
      else{
        inputHTML=`<input type="text" class="answer-input disabled" value="ì±„ì  ë¶ˆê°€ëŠ¥ ìœ í˜•" disabled />`;
      }   
      // --- ì…ë ¥ì¹¸ ìƒì„± ì´í›„ ---
      if(!["ê°ê´€ì‹","ê°ê´€ì‹(ë³µìˆ˜í˜•)"].includes(type)){
        inputHTML = inputHTML.replace(
          /(<input[^>]*class="[^"]*answer-input[^"]*"[^>]*>)/g,
          `<div class="formula-input">$1<div class="math-preview">ì…ë ¥í•œ ìˆ˜ì‹</div></div>`
        );
      }
      return `
        <div class="question-card" data-id="${q.id}">
          <div class="question-line">
            <h3>${q.question_no.replace("q","")}ë²ˆ</h3>
            ${inputHTML}
            <button class="check-btn">ì±„ì </button>
            <span class="result-inline"></span>
          </div>
          <input type="hidden" class="correct-answer" value="${ans}" />
          <input type="hidden" class="answer-type" value="${type}" />
          <input type="hidden" class="option1" value="${option1}" />
        </div>`;

    }).join("");

    /* ===== ì±„ì  ë¡œì§ ===== */
    function gradeQuestion(card){
      const btn=card.querySelector(".check-btn");
      const result=card.querySelector(".result-inline");
      const correct=card.querySelector(".correct-answer").value.trim();
      const type=card.querySelector(".answer-type").value.trim();
      const option1=card.querySelector(".option1").value.trim();
      const norm=normalize;
      // --- ë‹¨ë‹µí˜• ì±„ì 
      if(type === "ë‹¨ë‹µí˜•"){
        if(option1 === "ë‹¨í•­ì‹") {
          const user = normalize(card.querySelector(".answer-input")?.value.trim() || "");
          const corr = normalize(correct);
          return (user === corr) ? pass() : fail();          
        }
      }
      // --- í–‰ë ¬ ì±„ì 
      if(type==="í–‰ë ¬"){
          const corr = parseMatrixToGrid(correct);
          const user = [];
          const rows = corr.length;
          const cols = corr[0].length;

          for(let i=0;i<rows;i++){
            const rowVals=[];
            for(let j=0;j<cols;j++){
              const val=normalize(card.querySelector(`.matrix-cell[data-row="${i}"][data-col="${j}"]`)?.value||"");
              rowVals.push(val);
            }
            user.push(rowVals);
          }

          const sameSize = user.length===corr.length && user.every((r,i)=>r.length===corr[i].length);
          if(!sameSize) return fail();

          const ok = user.every((r,i)=>r.every((v,j)=>normalize(v)===normalize(corr[i][j])));
          return ok ? pass() : fail();
      }

      // --- ê¸°ë³¸ë¬¸ì¥ ì±„ì 
      if(type==="ê¸°ë³¸ë¬¸ì¥"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeBasicSentence(correct,user)?pass():fail();
      }
            // --- ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€) ì±„ì 
      if(type==="ë¬¸ì¥(ì •ë‹µì´ ì—¬ëŸ¬ ê°€ì§€)"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeMultiSentence(correct,user)?pass():fail();
      }

      // --- í•œê¸€ ììŒí˜• ì±„ì 
      if(type==="í•œê¸€ ììŒ") {
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeConsonantAnswer(correct,user)?pass():fail();
      }
      // --- ì¸ìˆ˜ë¶„í•´í˜• ì±„ì  ---
      if(type==="ì¸ìˆ˜ë¶„í•´"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeFactorization(correct,user)?pass():fail();
      }

      /* âœ… ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©) */
      if(type==="ìˆ˜ì‹(êµí™˜ë²•ì¹™ í—ˆìš©)"){
        const user=card.querySelector(".answer-input")?.value.trim()||"";
        return gradeCommutativeExpression(correct,user)?pass():fail();
      }

      // --- ê¸°ì¡´ ìœ í˜•ë“¤ ---
      if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•"){
        const expected = Object.fromEntries(parseKeyValuePairs(correct));
        const user = Object.fromEntries(
          [...card.querySelectorAll(".var-basic")].map(i=>[i.dataset.key, norm(i.value)])
        );
        const sameKeys = Object.keys(expected).length===Object.keys(user).length &&
                         Object.keys(expected).every(k=>user.hasOwnProperty(k));
        if(!sameKeys) return fail();
        const ok = Object.entries(expected).every(([k,v])=>user[k]===v);
        return ok ? pass() : fail();
      }
      if(type==="ì…ë ¥ ìˆœì„œ ìƒê´€ ì—†ìŒ"){ 
        const users=[...card.querySelectorAll(".order-agnostic")].map(i=>i.value);
        ok=gradeOrderAgnosticList(correct, users);
        return ok ? pass() : fail();
      }

      if(/^ë³€ìˆ˜\s*ëŒ€ì…í˜•\(ë°©ì •ì‹\)\(\d+ê°œ\)$/.test(type)){
        const n=parseInt(type.match(/\((\d+)ê°œ\)/)[1]);
        const varVals=[...card.querySelectorAll(".var-eq")].map(i=>norm(i.value));
        const extraVals=[...card.querySelectorAll(".extra-eq")].map(i=>norm(i.value));
        const corrVals = correct
          .replace(/\s*ë˜ëŠ”\s*/g, ",")
          .match(/=\s*([^,]+)/g)
          ?.map(x => x.replace(/^=\s*/, ""))
          .map(norm) || [];
        const afterEqPart = correct.split(/[^,]+=.+?(?:,|$)/).pop() || "";
        const corrExtras = afterEqPart.split(",").map(norm).filter(Boolean);
        const expected = [...corrVals, ...corrExtras];
        const user=[...varVals,...extraVals];
        if(user.length!==expected.length) return fail();
        return [...user].sort().join(",") === [...expected].sort().join(",") ? pass() : fail();
      }
      if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ë°©ì •ì‹)"){
        const inputs=[...card.querySelectorAll(".var-eq")].map(i=>norm(i.value));
        const corr = correct
          .replace(/\s*ë˜ëŠ”\s*/g, ",")
          .match(/=\s*([^,]+)/g)
          ?.map(x => x.replace(/^=\s*/, ""))
          .map(norm) || [];
        if(inputs.length!==corr.length) return fail();
        return ([...inputs].sort().join(",") === [...corr].sort().join(",")) ? pass() : fail();
      }
      if(type==="ë³€ìˆ˜ ëŒ€ì…í˜•(ì—°ë¦½ë°©ì •ì‹)"){
        const inputs=[...card.querySelectorAll(".var-system")].map(i=>i.value);
        return gradeSystemEquationAsMultiset(correct,inputs)?pass():fail();
      }

      const subInputs=card.querySelectorAll(".subans");
      if(subInputs.length>0){
        const correctParts=correct.replace(/\)\s*/g,") ")
          .split(/\(\d+\)|\([ê°€-ì‚¬]\)/)
          .map(x=>norm(x.replace(/^\)|\)$/g,""))).filter(Boolean);
        const userParts=[...subInputs].map(i=>norm(i.value));
        if(correctParts.length!==userParts.length) return fail();
        return correctParts.every((c,i)=>c===userParts[i])?pass():fail();
      }

      if(type==="ê°ê´€ì‹"){
        if(option1==="ë³µìˆ˜í˜•") {
          const chk=[...card.querySelectorAll("input[type=checkbox]:checked")].map(i=>i.value).join("");
          return (chk===correct)?pass():fail();
        }
        else {
          const sel=card.querySelector("input[type=radio]:checked")?.value;
          return (sel===correct)?pass():fail();
        }
      }
      /* ë¬¸ììˆ˜ì‹í˜• */
      if(type==="ë¬¸ììˆ˜ì‹"){
        const user=norm(card.querySelector(".answer-input")?.value.trim()||"");
        const corr=norm(correct);
        return (user===corr)?pass():fail();
      }

      const ans1=card.querySelector(".ans1")?.value.trim()||"";
      const ans2=card.querySelector(".ans2")?.value.trim()||"";

      if(/ëª«\s*:|ë‚˜ë¨¸ì§€\s*:/.test(correct))
        return gradeSpecialPair(correct,ans1,ans2,"ëª«","ë‚˜ë¨¸ì§€")?pass():fail();
      if(/ì‹¤ìˆ˜ë¶€ë¶„\s*:|í—ˆìˆ˜ë¶€ë¶„\s*:/.test(correct))
        return gradeSpecialPair(correct,ans1,ans2,"ì‹¤ìˆ˜ë¶€ë¶„","í—ˆìˆ˜ë¶€ë¶„")?pass():fail();
      if(/ìµœëŒ“ê°’\s*:|ìµœì†Ÿê°’\s*:/.test(correct))
        return gradeSpecialPair(correct,ans1,ans2,"ìµœëŒ“ê°’","ìµœì†Ÿê°’")?pass():fail();

      if(type==="ë“±ì‹í˜•"){
        const user=norm(card.querySelector(".answer-input")?.value.trim()||"");
        return (user===norm(correct))?pass():fail();
      }

      result.textContent="ì±„ì  ë¶ˆê°€ëŠ¥";
      result.className="result-inline";
      return;

      /* ===== ë‚´ë¶€ ìœ í‹¸ ===== */
      function pass(){
        result.textContent="âœ… ì •ë‹µ!";
        result.classList.add("correct");
        btn.classList.add("correct");
        btn.textContent="O";
        disableAll();
      }
      function fail(){
        result.textContent="âŒ ì˜¤ë‹µ..";
        result.classList.add("wrong");
        btn.classList.add("wrong");
        btn.textContent="X";
        card.classList.add("wrong");
        disableAll();
        // ë¬¸í•­ ë²ˆí˜¸ ê°€ì ¸ì˜¤ê¸°
        const qNo = card.querySelector("h3").textContent.replace("ë²ˆ","");
        // ì¤‘ë³µ ë°©ì§€í•˜ê³  ì €ì¥
        if(!wrongNumbers.includes(qNo)){
          wrongNumbers.push(qNo);
        }
      }
      function disableAll(){
        btn.disabled=true;
        card.classList.add("graded");
        card.querySelectorAll("input").forEach(i=>i.disabled=true);
      }
    }

    /* ê°œë³„ ì±„ì  + ëª¨ë‘ì±„ì  ë²„íŠ¼ */
    document.querySelectorAll(".check-btn").forEach(btn=>{
      btn.addEventListener("click",()=>gradeQuestion(btn.closest(".question-card")));
    });

    document.getElementById("check-all").addEventListener("click",()=>{
      document.querySelectorAll(".question-card").forEach(card=>{
        const btn=card.querySelector(".check-btn");
        if(btn && !btn.disabled) gradeQuestion(card);
      });
      document.getElementById("wrong-list").textContent =
      wrongNumbers.length ? `í‹€ë¦° ë¬¸ì œ: ${wrongNumbers.join(", ")}` : "";
    });
    document.addEventListener("input", e=>{
      // âœ… í–‰ë ¬í˜•ë§Œ ì œì™¸, ë‚˜ë¨¸ì§€ ëª¨ë“  text input ëŒ€ìƒ
      if(e.target.tagName === "INPUT" && e.target.type === "text" && !e.target.classList.contains("matrix-cell")){
        const val = e.target.value.trim();
        const preview = e.target.closest(".formula-input")?.querySelector(".math-preview");
        if(preview){
          preview.innerHTML = val ? `\\(${val}\\)` : "";
          MathJax.typesetPromise([preview]);
        }
      }
    });
  }catch(err){
    container.innerHTML="<p style='color:red;'>ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>";
  }
});
function logout(){
  localStorage.removeItem("workbook");
  alert("ë¡œê·¸ì•„ì›ƒ ë˜ì—ˆìŠµë‹ˆë‹¤.");
  location.href = "login.html";
}

</script>
</body>
</html>
